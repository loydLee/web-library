# 微前端

[TOC]

## 定义

> 借鉴后端微服务的概念。就是将一个大型高度聚合的前端工程拆分成一个一个的小工程。每一个小工程具备独立的开发、运行能力。而整个系统由这些小工程协同合作，实现所有页面的展示与交互

一个图表：

| 微服务                                                                                                                 | 微前端                                                                                                                                               |
| :--------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| 一个微服务由一组接口构成，接口地址一般是 URL。当微服务收到一个接口的请求时，会进行路由找到相应的`逻辑`，输出`响应内容` | 一个微前端由一组页面构成，页面地址也是 URL。当微前端收到一个页面 URL 的请求时，会进行路由找到相应的`组件`，渲染`页面内容`。                          |
| 后端微服务会有一个网关，作为单一入口接收所有的客户端接口请求，根据接口 URL 与服务的匹配关系，路由到对应的服务。        | 微前端则会有一个加载器，作为单一入口接收所有页面 URL 的访问，根据页面 URL 与微前端的匹配关系，选择加载对应的微前端，由该微前端进行进行路由响应 URL。 |

## 优点

- 与时俱进，引入新技术
- 局部/增量升级
- 代码简洁、解耦、更易维护
- 独立部署
- 组织更具扩展能力，其团队更加独立自治，提高效率

## 缺点

- 重复依赖
- 团队分裂（独立）更加明显
- 操作复杂性

## 微前端方案

> —— [知乎](https://www.jianshu.com/p/785c2ca5a886)

| 方式                | 开发成本 | 维护成本 | 可行性 | 统一框架要求 | 实现难度 | 潜在风险                             |
| :------------------ | :------- | :------- | ------ | ------------ | -------- | ------------------------------------ |
| 路由分发            | 低       | 低       | 高     | 否           | 1        | 方案普通                             |
| iFrame              | 低       | 低       | 高     | 否           | 1        | 方案普通                             |
| 应用微服务化        | 高       | 低       | 中     | 否           | 4        | 需针对每个框架定制及 HOOK            |
| 微件化              | 高       | 中       | 低     | 是           | 5        | 需针对构建系统，如 webpack 进行 hack |
| 微应用化            | 中       | 中       | 高     | 是           | 3        | 统一不同应用的构建规范               |
| 纯 Web Components   | 高       | 低       | 高     | 否           | 2        | 新技术，浏览器的兼容问题             |
| 结合 Web Components | 高       | 低       | 高     | 否           | 2        | 新技术，浏览器的兼容问题             |

## 现有微前端方案

- sing-spa
- qiankun
- icestark
- stencil
- 。。。

## 基于 icestark 的项目实战

> —— [icestark 官方文档](https://ice.work/docs/icestark/about)

### 简介

icestark 是一个面向大型系统的微前端解决方案，适用于以下业务场景：

- 后台比较分散，体验差别大，因为要频繁跳转导致操作效率低，希望能统一收口的一个系统内

- 单页面应用非常庞大，多人协作成本高，开发/构建时间长，依赖升级回归成本高

- 系统有二方/三方接入的需求

### 仿真系统接入示例

- 主框架：
  1、AppRouter 配置-主要是一些公共组件注册（eg:NotFound、LoadingComponent）,生命周期方法
  2、AppRoute 配置-配置子服务 title，path，basename,url---指定子服务地址，主要为 app.js 和 app.css
  3、router 配置（主框架自身路由配置，多用于子服务切换）
  4、代理-dev 环境下，需要将子服务用到的代理设置同步到主框架-`ice.config.js`
- 子服务：

  - vue:
    1、main.js

        ```js
        ...
        import { getMountNode, registerAppLeave } from '@ice/stark-app'
        ...
        const mountNode = getMountNode(document.getElementById('app')) // 获取节点

        const vue = new Vue({
          router,
          store,
          render: h => h(App)
        }).$mount()

        mountNode.appendChild(vue.$el) // 挂载节点

        registerAppLeave(() => {
          vue.$destroy() // 切换到其他服务注销实例
        })
        ```

    2、router(子服务需要定义基准路由)

        ```js
        ...
        import { getBasename } from '@ice/stark-app'

        // 路由配置
        const RouterConfig = {
          base: getBasename()
        }
        ...
        ```

    3、webpack 相关
    本次实践中，遇到几个问题：

    - 主框架中，我们对子服务的 app.js 以及 app.css 进行了引用，但是在实际开发中时，我们一般开启了文件 hash，这种情况下对资源的引用就成为了问题,因此，在 vue.config.js 中配置：

          ```js
          filenameHashing: false,
          css: {
            extract: true
          }
          ```

    - 生产环境下，子服务资源直接引用服务器地址，但是 dev 下，若开启了按需加载，publicPath 需定义为当前端口引用绝对地址，否则在主框架找不到按需加载的资源引起报错(包括且不限于路由中组件懒加载)
      `publicPath: 'http://localhost:8082/'`
